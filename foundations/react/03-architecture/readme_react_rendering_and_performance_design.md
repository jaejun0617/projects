# React Rendering & Performance Design (사고 체계 중심)

> 이 문서는 최적화 기법 모음이 아니다.  
> **React에서 렌더링이 언제, 왜 발생하는지**를 이해하고  
> 성능 최적화를 언제 해야 하는지를 판단하는 기준을 만든다.

---

## 🧭 이 챕터의 위치

- React useState & useEffect Design **이후**
- 실무 React 코드 작성 **직전/초기 단계**

즉,
- memo / useCallback 암기 ❌
- **렌더링 트리와 재계산 비용을 이해하는 단계** ✅

---

## 🎯 목표

- 리렌더링의 트리거를 정확히 구분한다
- 불필요한 최적화를 하지 않는다
- 성능 문제를 **측정 → 판단 → 해결**하는 사고 체계를 갖는다

---

## 1. 렌더링이란 무엇인가 (정의 재정의)

### 오해
- 렌더링 = DOM 변경

### 실제

> **렌더링 = UI를 계산하는 과정**

- JSX 평가
- 컴포넌트 함수 실행
- Virtual DOM 비교

DOM 변경은 그 다음 단계다.

---

## 2. 언제 리렌더가 발생하는가

### 리렌더 트리거

1. 상태(state) 변경
2. props 변경
3. 부모 컴포넌트 리렌더

👉 React는 **위에서 아래로** 렌더링한다

---

## 3. 리렌더링은 정말 나쁜가

### 결론

> **대부분의 리렌더는 문제가 아니다**

- 렌더링 = 함수 호출
- 비용은 대부분 작다

👉 DOM 변경이 비싸지, 렌더 계산은 상대적으로 싸다

---

## 4. 잘못된 최적화 패턴

```js
const Comp = memo(() => {
  return <div />;
});
```

### 문제

- 병목 지점 파악 없이 memo 사용
- 코드 복잡도 증가

👉 **측정 없는 최적화는 부채**

---

## 5. 성능 문제의 실제 원인

- 과도한 상태 범위
- 불필요한 상위 상태
- 무거운 계산 로직
- 대량 DOM 노드

👉 memo가 아니라 **구조 문제**인 경우가 많다

---

## 6. memo의 본질

### 정의

> **같은 입력(props)에 대해 같은 결과를 재사용**

- Pure Component 개념
- 비교 비용도 존재

👉 작은 컴포넌트에 남용 ❌

---

## 7. useCallback / useMemo의 진짜 목적

### 잘못된 사용

- 무조건 감싼다

### 올바른 사용

- 하위 컴포넌트 props 안정화
- 무거운 계산 캐싱

```js
const value = useMemo(() => heavyCalc(a), [a]);
```

---

## 8. 성능 최적화의 순서

1. 구조 개선 (상태 범위 축소)
2. 렌더 분리
3. 측정 (Profiler)
4. memo / useMemo / useCallback

👉 **훅은 마지막 수단**

---

## 9. React Profiler 사고 체계

- 언제 리렌더가 일어났는가
- 어떤 컴포넌트가 느린가
- 실제 병목은 어디인가

측정 없이는 판단하지 않는다.

---

## 10. 실무 체크리스트

- [ ] 이 리렌더는 실제로 문제인가?
- [ ] DOM 변경이 많은가?
- [ ] 상태 범위가 너무 넓지 않은가?
- [ ] 최적화가 가독성을 해치지 않는가?

---

## 🎯 이 챕터를 마치면

- 리렌더링 공포가 사라진다
- 성능 문제를 구조로 해결한다
- 필요할 때만 최적화한다

---

## 다음 챕터 예고

> **React Component Architecture Design**  
> 컴포넌트를 어떻게 나눠야 하는가

---

**이 문서는 React 성능 설계 기준 문서다.**