# React State Management Design (실무 아키텍처 기준)

> 이 문서는 특정 상태 관리 라이브러리를 설명하지 않는다.  
> **상태가 커질 때 왜 구조가 무너지는지, 그리고 어떤 기준으로 해결해야 하는지**를 다룬다.

---

## 🧭 이 챕터의 위치

- React Component Architecture Design **이후**
- 전역 상태 도입 **이전 필수 단계**

즉,
- Redux / Zustand 사용법 ❌
- **언제, 왜, 무엇을 써야 하는지 판단하는 단계** ✅

---

## 🎯 목표

- 상태의 성격을 분류한다
- local / lifted / global 상태의 경계를 정한다
- 불필요한 전역 상태를 만들지 않는다

---

## 1. 상태가 커질 때 발생하는 문제

### 증상

- props drilling 증가
- 상태 동기화 버그
- 리렌더 범위 예측 불가

👉 문제는 "라이브러리 부재"가 아니라 **설계 부재**다

---

## 2. 상태의 종류 (분류가 먼저)

### 2-1. UI State

- 모달 열림 여부
- 탭 선택
- 로딩 상태

👉 특정 화면에만 의미가 있다

---

### 2-2. Domain State

- 사용자 정보
- 장바구니
- 인증 상태

👉 여러 화면에서 공유된다

---

### 2-3. Server State

- API 응답 데이터
- 캐시 가능한 데이터

👉 최신성 / 재검증 문제가 핵심

---

## 3. 상태 위치 결정 원칙

> **상태는 가장 낮은 공통 조상에 둔다**

### 실패 사례

- 모든 상태를 App에 둠 ❌
- 모든 상태를 전역으로 둠 ❌

---

## 4. Local State

### 특징

- 컴포넌트 내부에 국한
- 빠르고 단순

### 언제 적합한가

- 다른 컴포넌트가 알 필요 없음
- 화면 전환 시 사라져도 무방

---

## 5. Lifted State

### 개념

- 상태를 상위로 끌어올림

### 목적

- 형제 컴포넌트 간 상태 공유

👉 대부분의 앱은 여기서 해결 가능

---

## 6. Global State의 오해

### 오해

- 상태가 많아지면 전역으로

### 실제

- 전역 상태는 **의존성 확산 장치**

👉 최소화해야 한다

---

## 7. Context의 역할

### Context는 무엇인가

- 상태 저장소 ❌
- **전달 메커니즘** ✅

### 주의점

- 값 변경 시 하위 전부 리렌더

---

## 8. 상태 관리 라이브러리는 왜 등장했는가

### 공통 해결 과제

- 전역 상태 공유
- 변경 추적
- 리렌더 제어

### 선택 기준

- 상태 성격
- 팀 규모
- 변경 빈도

---

## 9. 상태 관리 선택 가이드 (요약)

| 상황 | 선택 |
|---|---|
| 화면 내부 | local state |
| 형제 공유 | lifted state |
| 앱 전반 | global state |
| 서버 데이터 | server state lib |

---

## 10. 실무 체크리스트

- [ ] 이 상태는 정말 전역이어야 하는가?
- [ ] UI 상태를 도메인 상태와 섞지 않았는가?
- [ ] 서버 데이터 캐시 문제를 고려했는가?

---

## 🎯 이 챕터를 마치면

- 상태를 감으로 올리지 않는다
- 전역 상태 도입에 근거가 생긴다
- 라이브러리를 도구로 선택할 수 있다

---

## 다음 챕터 예고

> **Server State & Data Fetching Architecture**  
> 왜 React Query가 등장했는가

---

**이 문서는 React 상태 설계의 기준 문서다.**

