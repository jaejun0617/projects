# Day 17 — Control Flow (State-driven Loop Rendering)

🗓 **Date**  
2026-01-11 (Sun)

📌 **Topic**
- for 반복문
- 상태(state) 기반 반복 렌더링
- 이벤트 → 상태 변경 → UI 재계산
- 반복을 **UI 구조 생성 규칙**으로 해석하기

---

## ✅ 오늘 한 줄 요약
> 반복문은 코드를 여러 번 실행하는 문법이 아니라,  
> **상태를 기준으로 UI 구조를 반복 생성하는 규칙 엔진**이다.

---

## 📌 프로젝트 개요
Day 17은 반복문 문법을 익히는 날이 아니다.  
`for` 반복문을 사용해 **변하는 상태에 따라 화면 구조를 다시 그리는 사고**로 전환하는 단계다.

이 Day에서는:
- 콘솔 출력 중심 반복 사고 ❌
- **상태(state) → 반복 계산 → UI 렌더 사고** ✅

를 연습한다.

이 사고는 이후:
- 리스트 렌더링
- 카드 반복 출력
- React `map()` 기반 UI 렌더

로 그대로 이어진다.

---

## 🎯 미션 목표 (Mission Goals)
- 반복문을 “횟수 실행”이 아니라 **UI 구조 생성 도구**로 사용한다
- 버튼 인터랙션을 **상태 변경 이벤트**로 해석한다
- 상태 변경 후 항상 `render()`로 UI를 재계산한다
- 계산 로직과 UI 렌더링을 분리한다
- 퍼블리셔/프론트엔드 기준의 **구조 중심 코드**를 작성한다

---

## 🔥 오늘의 핵심 (Key Takeaways)
- 반복문은 UI를 여러 번 그리기 위한 기반 도구다
- 이벤트는 UI를 직접 수정하지 않고 **상태만 변경**한다
- 렌더링은 항상 **state → 계산 → 출력** 흐름을 따른다
- 이 구조는 React의 상태 기반 렌더링과 동일하다

---

## 🧠 핵심 개념 / 이론 요약

### 1️⃣ for 반복문 (설계 관점)
- 반복 범위가 명확한 경우 사용
- 카드 개수, 리스트 길이, 레이아웃 구조 생성

```js
for (let i = 1; i <= count; i++) {
  // i = 현재 UI 구조 인덱스
}
```

---

### 2️⃣ 이벤트 → 상태 → 렌더
- 사용자 이벤트는 UI를 직접 건드리지 않는다
- 상태를 변경하고 `render()`를 다시 호출한다

```js
state.count += 1;
render();
```

---

## 🏗️ 구현 기준 & 이 과제를 통해 기른 역량

### 구현 기준
- UI는 반드시 **state 기준으로만** 그린다
- 반복 결과는 문자열 기반 UI로 생성
- 이벤트 로직과 렌더 로직 분리
- DOM 직접 조작 최소화

### 기른 핵심 역량
- 반복문을 UI 구조 생성기로 해석하는 사고
- 상태 기반 렌더링 흐름 이해
- 실무형 인터랙션 코드의 기본 구조 습득
- 이후 React 리스트 렌더링 사고 완성

---

## 🏗️ 구현 내용 (UI 퍼블리셔 / 프론트엔드 과제)

### A. 요구사항
- `+ / -` 버튼으로 카드 개수 상태 변경
- 카드 개수는 0 미만으로 내려가지 않음
- 상태 변경 시 카드 UI 즉시 재렌더링
- 카드 개수만큼 동일한 카드 UI 반복 생성

### B. UI 구조 예시
```
[ Card 1 ]
[ Card 2 ]
[ Card 3 ]
...
```

---

## 📁 파일 구조
```txt
day-17/
├─ index.html
├─ css/
│  └─ style.css
├─ js/
│  └─ main.js
└─ README.md
```

---

## ⚙️ 핵심 코드 (구조 중심)

```js
// UI를 결정하는 단일 상태
const state = {
  count: 0,
};

// 카드 하나의 UI 규칙
function createCardHTML(index) {
  return `<div class="card">Card ${index}</div>`;
}

// 상태 → 반복 계산
function calculateCards(count) {
  let html = '';

  for (let i = 1; i <= count; i++) {
    html += createCardHTML(i);
  }

  return html;
}

// 상태 → UI 반영
function render() {
  countLabel.textContent = state.count;
  container.innerHTML = calculateCards(state.count);
}
```

---

## ✅ 제출 체크리스트
- [ ] 반복문이 UI 구조 생성에 사용되었는가?
- [ ] 이벤트가 상태만 변경하고 있는가?
- [ ] 상태 변경 후 render()로 UI를 재계산했는가?
- [ ] UI가 state 기준으로만 그려지는가?

---

## 🎯 얻어가는 점
- 반복문을 UI 구조 생성 도구로 바라보는 관점
- 상태 기반 인터랙션 렌더링 사고 체득
- 퍼블리셔 → 프론트엔드 사고 전환의 핵심 단계 완료

---

## 💻 사용 기술
- HTML5
- CSS3
- JavaScript (ES6)

---

## 🧠 마무리
Day 17의 핵심은 반복문을 많이 쓰는 것이 아니라,

> **상태 변화에 따라  
> 화면 구조를 다시 설계하는 사고를 획득하는 것**이다.
