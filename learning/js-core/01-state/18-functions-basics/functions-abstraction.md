# Day 18 — Functions (State-driven Interactive Design)

🗓 **Date**  
2026-01-12 (Mon)

📌 **Topic**
- 함수 책임 분리 (Single Responsibility)
- 상태(state) 기반 계산 로직
- 조건을 값으로 처리하는 설계
- 이벤트 → 상태 변경 → UI 재계산 흐름

---

## ✅ 오늘 한 줄 요약
> 함수는 문법 단위가 아니라,  
> **상태 기반 인터랙션을 안전하게 구성하기 위한 책임 분리 도구**다.

---

## 📌 프로젝트 개요 (WHY)

Day 18은 “계산기 만들기”가 목적이 아니다.  
이 Day의 핵심은 **Day 15~17에서 배운 사고를 함수 설계로 압축**하는 데 있다.

이 과제는 다음을 동시에 훈련한다.

- 상태(state)를 기준으로 UI가 결정되는 구조
- 계산 로직과 선택 로직을 함수 단위로 분리하는 감각
- 이벤트가 UI를 직접 조작하지 않도록 차단하는 설계
- 예외 상황에서도 인터랙션이 깨지지 않는 안정성

이 사고는 이후:
- 폼 처리 로직
- 비즈니스 로직 계층 분리
- React 컴포넌트 설계

로 자연스럽게 이어진다.

---

## 🎯 미션 목표 (Mission Goals)
- 사칙연산을 **단일 책임 함수**로 분리한다
- `calculator()`는 **연산 선택만 담당**하도록 제한한다
- 조건 분기를 “흐름 제어”가 아닌 **값 선택**으로 처리한다
- 이벤트는 상태만 변경하고, UI는 `render()`에서만 갱신한다
- Day 15~17과 **동일한 난이도의 인터랙티브 구조**를 유지한다

---

## 🔥 오늘의 핵심 (Key Takeaways)
- 함수는 재사용보다 **책임 분리**가 우선이다
- 상태가 바뀌면 UI는 항상 다시 계산된다
- 조건문은 분기 로직이 아니라 **값 결정 규칙**이다
- 인터랙션이 늘어날수록 구조 분리가 더 중요해진다

---

## 🧠 핵심 개념 / 설계 요약

### 1️⃣ 함수의 책임 분리
각 함수는 반드시 **하나의 역할만** 가진다.

- add / subtract / multiply / divide  
  → 계산만 담당  
  → UI / 이벤트 / 콘솔 출력 ❌

---

### 2️⃣ calculator 함수의 역할
`calculator`는 계산을 하지 않는다.

- 어떤 연산을 쓸지 **선택만** 한다
- 연산 로직은 매핑된 함수에 위임한다

이 구조는 연산 추가·변경 시
코드 전체를 건드리지 않게 해준다.

---

### 3️⃣ 상태 기반 인터랙션 흐름
```txt
User Action
 → state 변경
 → calculator()
 → render()
 → UI 재계산
```

이 흐름은 React의 `setState → render`와 동일하다.

---

## 🏗️ 구현 기준 & 이 과제를 통해 기른 역량

### 구현 기준
- UI는 반드시 **state 기준으로만** 결정
- 모든 계산 함수는 return만 사용
- 이벤트 핸들러에서 UI 직접 조작 금지
- 예외 상황에서도 앱이 멈추지 않도록 설계

### 기른 핵심 역량
- 함수 책임 분리 설계 능력
- 상태 기반 인터랙션 구조 이해
- 조건·예외 처리 안정성 감각
- 실무형 로직 구조의 기본기 완성

---

## 🏗️ 구현 내용 (인터랙티브 과제)

### A. 요구사항
- 숫자 2개와 연산자를 입력받는다
- 버튼 클릭 시 계산 수행
- 연산 결과를 즉시 UI에 반영
- 0으로 나누기 등 예외 상황 처리
- 잘못된 연산자는 에러 메시지 반환

---

## 📁 파일 구조
```txt
day-18/
├─ index.html
├─ css/
│  └─ style.css
├─ js/
│  └─ main.js
└─ README.md
```

---

## ⚙️ 핵심 코드 (구조 중심)

```js
// 연산자 → 함수 매핑
const OPERATIONS = {
  add,
  subtract,
  multiply,
  divide,
};

// 선택만 담당하는 계산기
function calculator(a, b, operator) {
  const operation = OPERATIONS[operator];
  if (!operation) return "유효하지 않은 연산자입니다.";
  return operation(a, b);
}
```

---

## ✅ 제출 체크리스트
- [ ] 함수들이 각자 하나의 책임만 가지는가?
- [ ] calculator가 계산 로직을 직접 가지지 않는가?
- [ ] 이벤트가 상태만 변경하고 있는가?
- [ ] UI가 state 기준으로만 렌더링되는가?

---

## 🎯 얻어가는 점
- 함수를 설계 단위로 바라보는 시각
- 상태·조건·함수를 결합하는 사고력
- 실무 인터랙션 코드의 최소 구조 체득

---

## 💻 사용 기술
- HTML5
- CSS3
- JavaScript (ES6)

---

## 🧠 마무리
Day 18의 핵심은 계산 결과가 아니라,

> **상태를 중심으로  
> 역할이 분리된 함수들이 협력하는 구조를 만드는 것**이다.
